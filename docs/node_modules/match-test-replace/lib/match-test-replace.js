"use strict";
// MIT Â© 2017 azu
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Apply ReturnResult order by last.
 */
var applyFixes = function (text, messages) {
    // As as result, show diff
    var remainingMessages = [];
    var cloneMessages = messages.slice();
    var fixes = cloneMessages;
    var lastFixPos = text.length + 1;
    var prefix = "";
    if (fixes.length) {
        // reverse: index larger is last
        fixes.sort(function (a, b) {
            if (a.index + a.match.length <= b.index) {
                return 1;
            }
            else {
                return -1;
            }
        });
        // split into array of characters for easier manipulation
        var chars_1 = text.split("");
        fixes.forEach(function (problem) {
            // pickup fix range
            var start = problem.index;
            var end = start + problem.match.length;
            // no replace
            if (problem.replace === undefined) {
                return;
            }
            var insertionText = problem.replace;
            if (end <= lastFixPos) {
                // modify
                chars_1.splice(start, end - start, insertionText);
                lastFixPos = start;
            }
            else {
                remainingMessages.push(problem);
            }
        });
        return {
            fixed: true,
            messages: cloneMessages,
            remainingMessages: remainingMessages,
            output: prefix + chars_1.join("")
        };
    }
    else {
        return {
            fixed: false,
            messages: cloneMessages,
            remainingMessages: remainingMessages,
            output: prefix + text
        };
    }
};
/**
 * replace `text` with `results`.
 */
exports.replaceAll = function (text, results) {
    var fixes = applyFixes(text, results);
    return {
        ok: fixes.fixed,
        output: fixes.output
    };
};
/**
 * test `text`, match `text`, and replace `text.
 */
exports.matchTestReplace = function (text, dict) {
    // No match
    if (!dict.pattern.test(text)) {
        return {
            ok: false,
            results: []
        };
    }
    var results = [];
    text.replace(dict.pattern, function replacer() {
        var isReplaceOK = true;
        // ...rest operator can do following
        // (match: string, ...captures: any[], offset: number, all: string) => string
        var match = arguments[0];
        var index = arguments[arguments.length - 2];
        var all = arguments[arguments.length - 1];
        var captures = Array.prototype.slice.call(arguments, 1, -2);
        var dictArgs = {
            index: index,
            match: match,
            captures: captures,
            all: all
        };
        if (typeof dict.test === "function") {
            isReplaceOK = dict.test(dictArgs);
        }
        if (isReplaceOK) {
            var replace = typeof dict.replace === "function" ? dict.replace(dictArgs) : undefined;
            var message = dict.message ? dict.message(dictArgs) : undefined;
            results.push({
                index: index,
                match: match,
                replace: replace,
                message: message
            });
            // no replace
            if (replace === undefined) {
                return all;
            }
            return replace;
        }
        else {
            // No replace
            return all;
        }
    });
    return {
        ok: true,
        results: results
    };
};
//# sourceMappingURL=match-test-replace.js.map
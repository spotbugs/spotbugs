{"version":3,"sources":["../src/textlint-rule-google-sentence-spacing.js"],"names":["require","RuleHelper","IgnoreNodeManager","StringSource","split","SentenceSyntax","Syntax","DocumentURL","report","context","RuleError","fixer","helper","Paragraph","node","isChildNode","Image","BlockQuote","Emphasis","ignoreNodeManager","ignoreChildrenByTypes","Code","Link","Html","source","sourceText","toString","sentences","spaces","index","indent","getSpace","length","nextSpace","push","setSpace","value","incrementCurrentSpace","space","forEach","sentenceOrWhiteSpace","type","WhiteSpace","range","filter","isFirstSpace","isLastSpace","originalIndex","originalIndexFromIndex","isIgnoredIndex","message","fix","replaceTextRange","module","exports","linter"],"mappings":"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","file":"textlint-rule-google-sentence-spacing.js","sourcesContent":["// MIT Â© 2017 azu\n\"use strict\";\n\nconst { RuleHelper, IgnoreNodeManager } = require(\"textlint-rule-helper\");\nconst StringSource = require(\"textlint-util-to-string\");\nconst { split, Syntax: SentenceSyntax } = require(\"sentence-splitter\");\nconst DocumentURL = \"https://developers.google.com/style/sentence-spacing\";\nconst report = context => {\n    const { Syntax, RuleError, fixer, report } = context;\n    const helper = new RuleHelper(context);\n    // Ignore following pattern\n    // Paragraph > Link Code Html ...\n    return {\n        [Syntax.Paragraph](node) {\n            if (helper.isChildNode(node, [Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {\n                return;\n            }\n            const ignoreNodeManager = new IgnoreNodeManager();\n            ignoreNodeManager.ignoreChildrenByTypes(node, [Syntax.Code, Syntax.Link, Syntax.BlockQuote, Syntax.Html]);\n            const source = new StringSource(node);\n            const sourceText = source.toString();\n            const sentences = split(sourceText);\n            /**\n             * @type {[{index:number,indent:number]}\n             */\n            const spaces = [\n                {\n                    index: 0,\n                    indent: 0\n                }\n            ];\n            const getSpace = () => {\n                return spaces[spaces.length - 1];\n            };\n            /**\n             * create and set next space\n             * @param {number} index next start index\n             */\n            const nextSpace = index => {\n                spaces.push({\n                    index,\n                    indent: 0\n                });\n            };\n            const setSpace = value => {\n                spaces[spaces.length - 1] = value;\n            };\n            const incrementCurrentSpace = () => {\n                const space = getSpace();\n                setSpace({\n                    index: space.index,\n                    indent: space.indent + 1\n                });\n            };\n            // counting\n            sentences.forEach(sentenceOrWhiteSpace => {\n                if (sentenceOrWhiteSpace.type === SentenceSyntax.WhiteSpace && sentenceOrWhiteSpace.value === \" \") {\n                    return incrementCurrentSpace();\n                }\n                nextSpace(sentenceOrWhiteSpace.range[1]);\n            });\n\n            // Report based on space\n            spaces\n                .filter(space => space.indent >= 2)\n                .filter(space => {\n                    // Allow to write first space and last space.\n                    // This rule only treat \"space between sentences\"\n                    const isFirstSpace = space.index === 0;\n                    const isLastSpace = space.index + space.indent === sentences[sentences.length - 1].range[1];\n                    if (isFirstSpace) {\n                        return false;\n                    } else if (isLastSpace) {\n                        return false;\n                    }\n                    const originalIndex = source.originalIndexFromIndex(space.index);\n                    // if the error is ignored, don't report\n                    if (ignoreNodeManager.isIgnoredIndex(originalIndex)) {\n                        return false;\n                    }\n                    // other should report\n                    return true;\n                })\n                .forEach(space => {\n                    const originalIndex = source.originalIndexFromIndex(space.index);\n                    const message = `Leave only one space between sentences. Number of space: ${space.indent}\n${DocumentURL}`;\n                    report(\n                        node,\n                        new RuleError(message, {\n                            index: originalIndex,\n                            fix: fixer.replaceTextRange([originalIndex, originalIndex + space.indent], \" \")\n                        })\n                    );\n                });\n        }\n    };\n};\nmodule.exports = {\n    linter: report,\n    fixer: report\n};\n"]}
// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Syntax = undefined;
exports.split = split;
exports.createWhiteSpaceNode = createWhiteSpaceNode;
exports.createSentenceNode = createSentenceNode;

var _structuredSource = require("structured-source");

var _structuredSource2 = _interopRequireDefault(_structuredSource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var assert = require("assert");


var defaultOptions = {
    // charRegExp is deprecated
    charRegExp: /[\.。\?\!？！]/,
    // separator char list
    separatorChars: [".", "。", "?", "!", "？", "！"],
    newLineCharacters: "\n",
    whiteSpaceCharacters: [" ", "　"]
};
var Syntax = exports.Syntax = {
    WhiteSpace: "WhiteSpace",
    Sentence: "Sentence"
};

/**
 * @param {string} text
 * @param {{
 *      charRegExp: ?Object,
 *      separatorChars: ?string[],
 *      newLineCharacters: ?String,
 *      whiteSpaceCharacters: ?string[]
 *  }} options
 * @returns {Array}
 */
function split(text) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var charRegExp = options.charRegExp;
    var separatorChars = options.separatorChars || defaultOptions.separatorChars;
    var whiteSpaceCharacters = options.whiteSpaceCharacters || defaultOptions.whiteSpaceCharacters;
    assert(!(options.charRegExp && options.separatorChars), "should use either one `charRegExp` or `separatorChars`.\n" + "`charRegExp` is deprecated.");
    /**
     * Is the `char` separator symbol?
     * @param {string} char
     * @returns {boolean}
     */
    var testCharIsSeparator = function testCharIsSeparator(char) {
        if (charRegExp) {
            return charRegExp.test(char);
        }
        return separatorChars.indexOf(char) !== -1;
    };
    var newLineCharacters = options.newLineCharacters || defaultOptions.newLineCharacters;
    var src = new _structuredSource2.default(text);
    var createNode = function createNode(type, start, end) {
        var range = [start, end];
        var location = src.rangeToLocation(range);
        var slicedText = text.slice(start, end);
        var node = void 0;
        if (type === Syntax.WhiteSpace) {
            node = createWhiteSpaceNode(slicedText, location, range);
        } else if (type === Syntax.Sentence) {
            node = createSentenceNode(slicedText, location, range);
        }
        return node;
    };
    var results = [];
    var startPoint = 0;
    var currentIndex = 0;
    var isSplitPoint = false;
    var isInSentence = false;
    var newLineCharactersLength = newLineCharacters.length;
    for (; currentIndex < text.length; currentIndex++) {
        var char = text[currentIndex];
        var whiteTarget = text.slice(currentIndex, currentIndex + newLineCharactersLength);
        if (whiteTarget === newLineCharacters) {
            // (string)\n
            if (startPoint !== currentIndex) {
                results.push(createNode(Syntax.Sentence, startPoint, currentIndex));
            }
            for (var i = 0; i < newLineCharactersLength; i++) {
                // string(\n)
                var startIndex = currentIndex + i;
                results.push(createNode(Syntax.WhiteSpace, startIndex, startIndex + 1));
            }
            // string\n|
            startPoint = currentIndex + newLineCharactersLength;
            isSplitPoint = false;
        } else if (testCharIsSeparator(char)) {
            isSplitPoint = true;
        } else {
            // why `else`
            // it for support 。。。 pattern
            if (isSplitPoint) {
                results.push(createNode(Syntax.Sentence, startPoint, currentIndex));
                // reset stat
                startPoint = currentIndex;
                isSplitPoint = false;
                isInSentence = false;
            }
            // Sentence<WhiteSpace>*Sentence
            if (isInSentence === false && whiteSpaceCharacters.indexOf(char) !== -1) {
                // Add WhiteSpace
                results.push(createNode(Syntax.WhiteSpace, startPoint, currentIndex + 1));
                startPoint++;
            } else {
                // New sentence start
                isInSentence = true;
            }
        }
    }

    if (startPoint !== currentIndex) {
        results.push(createNode(Syntax.Sentence, startPoint, currentIndex));
    }
    return results;
}

/**
 * @param {string} text
 * @param {Object} loc
 * @param {number[]} range
 * @returns {{type: string, raw: string, value: string, loc: Object, range: number[]}}
 */
function createWhiteSpaceNode(text, loc, range) {
    return {
        type: "WhiteSpace",
        raw: text,
        value: text,
        loc: loc,
        range: range
    };
}

/**
 * @param {string} text
 * @param {Object} loc
 * @param {number[]} range
 * @returns {{type: string, raw: string, value: string, loc: Object, range: number[]}}
 */
function createSentenceNode(text, loc, range) {
    return {
        type: "Sentence",
        raw: text,
        value: text,
        loc: loc,
        range: range
    };
}
//# sourceMappingURL=sentence-splitter.js.map
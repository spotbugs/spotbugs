{"version":3,"sources":["../src/sentence-splitter.js"],"names":["split","createWhiteSpaceNode","createSentenceNode","assert","require","defaultOptions","charRegExp","separatorChars","newLineCharacters","whiteSpaceCharacters","Syntax","WhiteSpace","Sentence","text","options","testCharIsSeparator","test","char","indexOf","src","createNode","type","start","end","range","location","rangeToLocation","slicedText","slice","node","results","startPoint","currentIndex","isSplitPoint","isInSentence","newLineCharactersLength","length","whiteTarget","push","i","startIndex","loc","raw","value"],"mappings":"AAAA;AACA;;;;;;QA2BgBA,K,GAAAA,K;QA2FAC,oB,GAAAA,oB;QAgBAC,kB,GAAAA,kB;;AApIhB;;;;;;AADA,IAAMC,SAASC,QAAQ,QAAR,CAAf;;;AAGA,IAAMC,iBAAiB;AACnB;AACAC,gBAAY,aAFO;AAGnB;AACAC,oBAAgB,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,CAJG;AAKnBC,uBAAmB,IALA;AAMnBC,0BAAsB,CAAC,GAAD,EAAM,GAAN;AANH,CAAvB;AAQO,IAAMC,0BAAS;AAClBC,gBAAY,YADM;AAElBC,cAAU;AAFQ,CAAf;;AAKP;;;;;;;;;;AAUO,SAASZ,KAAT,CAAea,IAAf,EAAmC;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AACtC,QAAMR,aAAaQ,QAAQR,UAA3B;AACA,QAAMC,iBAAiBO,QAAQP,cAAR,IAA0BF,eAAeE,cAAhE;AACA,QAAME,uBAAuBK,QAAQL,oBAAR,IAAgCJ,eAAeI,oBAA5E;AACAN,WACI,EAAEW,QAAQR,UAAR,IAAsBQ,QAAQP,cAAhC,CADJ,EAEI,8DAA8D,6BAFlE;AAIA;;;;;AAKA,QAAMQ,sBAAsB,SAAtBA,mBAAsB,OAAQ;AAChC,YAAIT,UAAJ,EAAgB;AACZ,mBAAOA,WAAWU,IAAX,CAAgBC,IAAhB,CAAP;AACH;AACD,eAAOV,eAAeW,OAAf,CAAuBD,IAAvB,MAAiC,CAAC,CAAzC;AACH,KALD;AAMA,QAAMT,oBAAoBM,QAAQN,iBAAR,IAA6BH,eAAeG,iBAAtE;AACA,QAAMW,MAAM,+BAAoBN,IAApB,CAAZ;AACA,QAAMO,aAAa,SAAbA,UAAa,CAACC,IAAD,EAAOC,KAAP,EAAcC,GAAd,EAAsB;AACrC,YAAIC,QAAQ,CAACF,KAAD,EAAQC,GAAR,CAAZ;AACA,YAAIE,WAAWN,IAAIO,eAAJ,CAAoBF,KAApB,CAAf;AACA,YAAIG,aAAad,KAAKe,KAAL,CAAWN,KAAX,EAAkBC,GAAlB,CAAjB;AACA,YAAIM,aAAJ;AACA,YAAIR,SAASX,OAAOC,UAApB,EAAgC;AAC5BkB,mBAAO5B,qBAAqB0B,UAArB,EAAiCF,QAAjC,EAA2CD,KAA3C,CAAP;AACH,SAFD,MAEO,IAAIH,SAASX,OAAOE,QAApB,EAA8B;AACjCiB,mBAAO3B,mBAAmByB,UAAnB,EAA+BF,QAA/B,EAAyCD,KAAzC,CAAP;AACH;AACD,eAAOK,IAAP;AACH,KAXD;AAYA,QAAIC,UAAU,EAAd;AACA,QAAIC,aAAa,CAAjB;AACA,QAAIC,eAAe,CAAnB;AACA,QAAIC,eAAe,KAAnB;AACA,QAAIC,eAAe,KAAnB;AACA,QAAMC,0BAA0B3B,kBAAkB4B,MAAlD;AACA,WAAOJ,eAAenB,KAAKuB,MAA3B,EAAmCJ,cAAnC,EAAmD;AAC/C,YAAIf,OAAOJ,KAAKmB,YAAL,CAAX;AACA,YAAIK,cAAcxB,KAAKe,KAAL,CAAWI,YAAX,EAAyBA,eAAeG,uBAAxC,CAAlB;AACA,YAAIE,gBAAgB7B,iBAApB,EAAuC;AACnC;AACA,gBAAIuB,eAAeC,YAAnB,EAAiC;AAC7BF,wBAAQQ,IAAR,CAAalB,WAAWV,OAAOE,QAAlB,EAA4BmB,UAA5B,EAAwCC,YAAxC,CAAb;AACH;AACD,iBAAK,IAAIO,IAAI,CAAb,EAAgBA,IAAIJ,uBAApB,EAA6CI,GAA7C,EAAkD;AAC9C;AACA,oBAAIC,aAAaR,eAAeO,CAAhC;AACAT,wBAAQQ,IAAR,CAAalB,WAAWV,OAAOC,UAAlB,EAA8B6B,UAA9B,EAA0CA,aAAa,CAAvD,CAAb;AACH;AACD;AACAT,yBAAaC,eAAeG,uBAA5B;AACAF,2BAAe,KAAf;AACH,SAbD,MAaO,IAAIlB,oBAAoBE,IAApB,CAAJ,EAA+B;AAClCgB,2BAAe,IAAf;AACH,SAFM,MAEA;AACH;AACA;AACA,gBAAIA,YAAJ,EAAkB;AACdH,wBAAQQ,IAAR,CAAalB,WAAWV,OAAOE,QAAlB,EAA4BmB,UAA5B,EAAwCC,YAAxC,CAAb;AACA;AACAD,6BAAaC,YAAb;AACAC,+BAAe,KAAf;AACAC,+BAAe,KAAf;AACH;AACD;AACA,gBAAIA,iBAAiB,KAAjB,IAA0BzB,qBAAqBS,OAArB,CAA6BD,IAA7B,MAAuC,CAAC,CAAtE,EAAyE;AACrE;AACAa,wBAAQQ,IAAR,CAAalB,WAAWV,OAAOC,UAAlB,EAA8BoB,UAA9B,EAA0CC,eAAe,CAAzD,CAAb;AACAD;AACH,aAJD,MAIO;AACH;AACAG,+BAAe,IAAf;AACH;AACJ;AACJ;;AAED,QAAIH,eAAeC,YAAnB,EAAiC;AAC7BF,gBAAQQ,IAAR,CAAalB,WAAWV,OAAOE,QAAlB,EAA4BmB,UAA5B,EAAwCC,YAAxC,CAAb;AACH;AACD,WAAOF,OAAP;AACH;;AAED;;;;;;AAMO,SAAS7B,oBAAT,CAA8BY,IAA9B,EAAoC4B,GAApC,EAAyCjB,KAAzC,EAAgD;AACnD,WAAO;AACHH,cAAM,YADH;AAEHqB,aAAK7B,IAFF;AAGH8B,eAAO9B,IAHJ;AAIH4B,aAAKA,GAJF;AAKHjB,eAAOA;AALJ,KAAP;AAOH;;AAED;;;;;;AAMO,SAAStB,kBAAT,CAA4BW,IAA5B,EAAkC4B,GAAlC,EAAuCjB,KAAvC,EAA8C;AACjD,WAAO;AACHH,cAAM,UADH;AAEHqB,aAAK7B,IAFF;AAGH8B,eAAO9B,IAHJ;AAIH4B,aAAKA,GAJF;AAKHjB,eAAOA;AALJ,KAAP;AAOH","file":"sentence-splitter.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst assert = require(\"assert\");\nimport StructureSource from \"structured-source\";\n\nconst defaultOptions = {\n    // charRegExp is deprecated\n    charRegExp: /[\\.。\\?\\!？！]/,\n    // separator char list\n    separatorChars: [\".\", \"。\", \"?\", \"!\", \"？\", \"！\"],\n    newLineCharacters: \"\\n\",\n    whiteSpaceCharacters: [\" \", \"　\"]\n};\nexport const Syntax = {\n    WhiteSpace: \"WhiteSpace\",\n    Sentence: \"Sentence\"\n};\n\n/**\n * @param {string} text\n * @param {{\n *      charRegExp: ?Object,\n *      separatorChars: ?string[],\n *      newLineCharacters: ?String,\n *      whiteSpaceCharacters: ?string[]\n *  }} options\n * @returns {Array}\n */\nexport function split(text, options = {}) {\n    const charRegExp = options.charRegExp;\n    const separatorChars = options.separatorChars || defaultOptions.separatorChars;\n    const whiteSpaceCharacters = options.whiteSpaceCharacters || defaultOptions.whiteSpaceCharacters;\n    assert(\n        !(options.charRegExp && options.separatorChars),\n        \"should use either one `charRegExp` or `separatorChars`.\\n\" + \"`charRegExp` is deprecated.\"\n    );\n    /**\n     * Is the `char` separator symbol?\n     * @param {string} char\n     * @returns {boolean}\n     */\n    const testCharIsSeparator = char => {\n        if (charRegExp) {\n            return charRegExp.test(char);\n        }\n        return separatorChars.indexOf(char) !== -1;\n    };\n    const newLineCharacters = options.newLineCharacters || defaultOptions.newLineCharacters;\n    const src = new StructureSource(text);\n    const createNode = (type, start, end) => {\n        let range = [start, end];\n        let location = src.rangeToLocation(range);\n        let slicedText = text.slice(start, end);\n        let node;\n        if (type === Syntax.WhiteSpace) {\n            node = createWhiteSpaceNode(slicedText, location, range);\n        } else if (type === Syntax.Sentence) {\n            node = createSentenceNode(slicedText, location, range);\n        }\n        return node;\n    };\n    let results = [];\n    let startPoint = 0;\n    let currentIndex = 0;\n    let isSplitPoint = false;\n    let isInSentence = false;\n    const newLineCharactersLength = newLineCharacters.length;\n    for (; currentIndex < text.length; currentIndex++) {\n        let char = text[currentIndex];\n        let whiteTarget = text.slice(currentIndex, currentIndex + newLineCharactersLength);\n        if (whiteTarget === newLineCharacters) {\n            // (string)\\n\n            if (startPoint !== currentIndex) {\n                results.push(createNode(Syntax.Sentence, startPoint, currentIndex));\n            }\n            for (let i = 0; i < newLineCharactersLength; i++) {\n                // string(\\n)\n                let startIndex = currentIndex + i;\n                results.push(createNode(Syntax.WhiteSpace, startIndex, startIndex + 1));\n            }\n            // string\\n|\n            startPoint = currentIndex + newLineCharactersLength;\n            isSplitPoint = false;\n        } else if (testCharIsSeparator(char)) {\n            isSplitPoint = true;\n        } else {\n            // why `else`\n            // it for support 。。。 pattern\n            if (isSplitPoint) {\n                results.push(createNode(Syntax.Sentence, startPoint, currentIndex));\n                // reset stat\n                startPoint = currentIndex;\n                isSplitPoint = false;\n                isInSentence = false;\n            }\n            // Sentence<WhiteSpace>*Sentence\n            if (isInSentence === false && whiteSpaceCharacters.indexOf(char) !== -1) {\n                // Add WhiteSpace\n                results.push(createNode(Syntax.WhiteSpace, startPoint, currentIndex + 1));\n                startPoint++;\n            } else {\n                // New sentence start\n                isInSentence = true;\n            }\n        }\n    }\n\n    if (startPoint !== currentIndex) {\n        results.push(createNode(Syntax.Sentence, startPoint, currentIndex));\n    }\n    return results;\n}\n\n/**\n * @param {string} text\n * @param {Object} loc\n * @param {number[]} range\n * @returns {{type: string, raw: string, value: string, loc: Object, range: number[]}}\n */\nexport function createWhiteSpaceNode(text, loc, range) {\n    return {\n        type: \"WhiteSpace\",\n        raw: text,\n        value: text,\n        loc: loc,\n        range: range\n    };\n}\n\n/**\n * @param {string} text\n * @param {Object} loc\n * @param {number[]} range\n * @returns {{type: string, raw: string, value: string, loc: Object, range: number[]}}\n */\nexport function createSentenceNode(text, loc, range) {\n    return {\n        type: \"Sentence\",\n        raw: text,\n        value: text,\n        loc: loc,\n        range: range\n    };\n}\n"]}
{"version":3,"sources":["../src/checkBoldTextPrecedingColon.js"],"names":["checkBoldTextPrecedingColon","node","Syntax","RuleError","getSource","fixer","report","children","BoldNodeList","filter","childNode","type","Strong","forEach","currentIndex","indexOf","boldNode","nextNodeOfBold","Str","nextNodeValue","nextCharacter","charAt","message","Array","isArray","strNodeOfBoldNode","index","range","fix","replaceText","removeRange"],"mappings":"AAAA;AACA;;;;;AACO,IAAMA,oEAA8B,SAA9BA,2BAA8B,OAA2D;AAAA,QAAxDC,IAAwD,QAAxDA,IAAwD;AAAA,QAAlDC,MAAkD,QAAlDA,MAAkD;AAAA,QAA1CC,SAA0C,QAA1CA,SAA0C;AAAA,QAA/BC,SAA+B,QAA/BA,SAA+B;AAAA,QAApBC,KAAoB,QAApBA,KAAoB;AAAA,QAAbC,MAAa,QAAbA,MAAa;;AAClG,QAAMC,WAAWN,KAAKM,QAAtB;AACA,QAAI,CAACA,QAAL,EAAe;AACX;AACH;AACD,QAAMC,eAAeD,SAASE,MAAT,CAAgB,qBAAa;AAC9C,eAAOC,UAAUC,IAAV,KAAmBT,OAAOU,MAAjC;AACH,KAFoB,CAArB;;AAIAJ,iBAAaK,OAAb,CAAqB,oBAAY;AAC7B,YAAMC,eAAeP,SAASQ,OAAT,CAAiBC,QAAjB,CAArB;AACA,YAAMC,iBAAiBV,SAASO,eAAe,CAAxB,CAAvB;AACA,YAAI,CAACG,cAAL,EAAqB;AACjB;AACH;AACD,YAAIA,eAAeN,IAAf,KAAwBT,OAAOgB,GAAnC,EAAwC;AACpC;AACH;AACD,YAAMC,gBAAgBf,UAAUa,cAAV,CAAtB;AACA,YAAI,CAACE,aAAL,EAAoB;AAChB;AACH;AACD,YAAMC,gBAAgBD,cAAcE,MAAd,CAAqB,CAArB,CAAtB;AACA,YAAID,kBAAkB,GAAtB,EAA2B;AACvB;AACH;AACD;AACA,YAAME,qJAAN;AAGA,YAAI,CAACC,MAAMC,OAAN,CAAcR,SAAST,QAAvB,CAAL,EAAuC;AACnC;AACH;AACD,YAAMkB,oBAAoBT,SAAST,QAAT,CAAkB,CAAlB,CAA1B;AACA,YAAI,CAACkB,iBAAD,IAAsBA,kBAAkBd,IAAlB,KAA2BT,OAAOgB,GAA5D,EAAiE;AAC7D;AACH;AACDZ,eACImB,iBADJ,EAEI,IAAItB,SAAJ,CAAcmB,OAAd,EAAuB;AACnBI,mBAAOD,kBAAkBE,KAAlB,CAAwB,CAAxB,IAA6B1B,KAAK0B,KAAL,CAAW,CAAX,CADjB;AAEnBC,iBAAKvB,MAAMwB,WAAN,CAAkBJ,iBAAlB,EAAwCrB,UAAUqB,iBAAV,CAAxC;AAFc,SAAvB,CAFJ;AAOA;AACAnB,eACIW,cADJ,EAEI,IAAId,SAAJ,CAAcmB,OAAd,EAAuB;AACnBI,mBAAO,CADY;AAEnBE,iBAAKvB,MAAMyB,WAAN,CAAkB,CAAC,CAAD,EAAI,CAAJ,CAAlB;AAFc,SAAvB,CAFJ;AAOH,KA3CD;AA4CH,CArDM","file":"checkBoldTextPrecedingColon.js","sourcesContent":["// MIT Â© 2017 azu\n\"use strict\";\nexport const checkBoldTextPrecedingColon = ({ node, Syntax, RuleError, getSource, fixer, report }) => {\n    const children = node.children;\n    if (!children) {\n        return;\n    }\n    const BoldNodeList = children.filter(childNode => {\n        return childNode.type === Syntax.Strong;\n    });\n\n    BoldNodeList.forEach(boldNode => {\n        const currentIndex = children.indexOf(boldNode);\n        const nextNodeOfBold = children[currentIndex + 1];\n        if (!nextNodeOfBold) {\n            return;\n        }\n        if (nextNodeOfBold.type !== Syntax.Str) {\n            return;\n        }\n        const nextNodeValue = getSource(nextNodeOfBold);\n        if (!nextNodeValue) {\n            return;\n        }\n        const nextCharacter = nextNodeValue.charAt(0);\n        if (nextCharacter !== \":\") {\n            return;\n        }\n        // add `:` to current node\n        const message = `When the text preceding a colon is bold, make the colon bold too.\nhttps://developers.google.com/style/colons#bold-text-preceding-colon\n`;\n        if (!Array.isArray(boldNode.children)) {\n            return;\n        }\n        const strNodeOfBoldNode = boldNode.children[0];\n        if (!strNodeOfBoldNode || strNodeOfBoldNode.type !== Syntax.Str) {\n            return;\n        }\n        report(\n            strNodeOfBoldNode,\n            new RuleError(message, {\n                index: strNodeOfBoldNode.range[0] - node.range[0],\n                fix: fixer.replaceText(strNodeOfBoldNode, `${getSource(strNodeOfBoldNode)}:`)\n            })\n        );\n        // remove `:` from next node\n        report(\n            nextNodeOfBold,\n            new RuleError(message, {\n                index: 0,\n                fix: fixer.removeRange([0, 1])\n            })\n        );\n    });\n};\n"]}
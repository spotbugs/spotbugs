"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parse = parse;

var _child_process = require("child_process");

var _traverse = require("traverse");

var _traverse2 = _interopRequireDefault(_traverse);

var _structuredSource = require("structured-source");

var _structuredSource2 = _interopRequireDefault(_structuredSource);

var _mapping = require("./mapping");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function filterAndReplaceNodeAttributes(node) {
    Object.keys(_mapping.reSTAttributeKeyMap).forEach(function (key) {
        var v = node[key];
        node[_mapping.reSTAttributeKeyMap[key]] = v;
        if (v !== undefined) {
            delete node[key];
        }
    });
}

/**
 * parse reStructuredText and return ast mapped location info.
 * @param {string} text
 * @returns {TxtNode}
 */
function parse(text) {
    var ast = JSON.parse((0, _child_process.execSync)("rst2ast -q", { input: text }));
    var src = new _structuredSource2.default(text);
    (0, _traverse2.default)(ast).forEach(function (node) {
        if (this.notLeaf) {
            filterAndReplaceNodeAttributes(node);
            // type
            if (node.type === null) {
                node.type = "text";
            }
            node.type = _mapping.syntaxMap[node.type];
            if (!node.type) {
                node.type = "Unknown";
            }
            // raw
            node.raw = node.raw || node.value || "";
            // loc
            var lines = node.raw.split("\n");
            if (node.line) {
                node.loc = {
                    start: { line: node.line.start, column: 0 },
                    end: { line: node.line.end, column: lines[lines.length - 1].length }
                };
                node.range = src.locationToRange(node.loc);
                delete node.line;
            }
        }
    });
    return ast;
}
//# sourceMappingURL=rst-to-ast.js.map
// LICENSE : MIT
"use strict";
/**
 * RuleHelper is helper class for textlint.
 * @class RuleHelper
 */

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RuleHelper = function () {
    /**
     * Initialize RuleHelper with RuleContext object.
     * @param {RuleContext} ruleContext the ruleContext is context object of the rule.
     */

    function RuleHelper(ruleContext) {
        _classCallCheck(this, RuleHelper);

        this.ruleContext = ruleContext;
    }

    /**
     * Get parents of node.
     * The parent nodes are returned in order from the closest parent to the outer ones.
     * {@link node} is not contained in the results.
     * @param {TxtNode} node the node is start point.
     * @returns {TxtNode[]}
     */


    _createClass(RuleHelper, [{
        key: "getParents",
        value: function getParents(node) {
            var result = [];
            var parent = node.parent;
            while (parent != null) {
                result.push(parent);
                parent = parent.parent;
            }
            return result;
        }

        /**
         * Return true if `node` is wrapped any one of node {@link types}.
         * @param {TxtNode} node is target node
         * @param {string[]} types are wrapped target node
         * @returns {boolean}
         */

    }, {
        key: "isChildNode",
        value: function isChildNode(node, types) {
            var parents = this.getParents(node);
            var parentsTypes = parents.map(function (parent) {
                return parent.type;
            });
            return types.some(function (type) {
                return parentsTypes.some(function (parentType) {
                    return parentType === type;
                });
            });
        }
    }]);

    return RuleHelper;
}();

exports.default = RuleHelper;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy90ZXh0bGludC1ydWxlLWhlbHBlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBS3FCLFU7Ozs7OztBQUtqQix3QkFBWSxXQUFaLEVBQXlCO0FBQUE7O0FBQ3JCLGFBQUssV0FBTCxHQUFtQixXQUFuQjtBQUNIOzs7Ozs7Ozs7Ozs7O21DQVNVLEksRUFBTTtBQUNiLGdCQUFJLFNBQVMsRUFBYjtBQUNBLGdCQUFJLFNBQVMsS0FBSyxNQUFsQjtBQUNBLG1CQUFPLFVBQVUsSUFBakIsRUFBdUI7QUFDbkIsdUJBQU8sSUFBUCxDQUFZLE1BQVo7QUFDQSx5QkFBUyxPQUFPLE1BQWhCO0FBQ0g7QUFDRCxtQkFBTyxNQUFQO0FBQ0g7Ozs7Ozs7Ozs7O29DQVFXLEksRUFBTSxLLEVBQU87QUFDckIsZ0JBQUksVUFBVSxLQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBZDtBQUNBLGdCQUFJLGVBQWUsUUFBUSxHQUFSLENBQVksVUFBVSxNQUFWLEVBQWtCO0FBQzdDLHVCQUFPLE9BQU8sSUFBZDtBQUNILGFBRmtCLENBQW5CO0FBR0EsbUJBQU8sTUFBTSxJQUFOLENBQVcsVUFBVSxJQUFWLEVBQWdCO0FBQzlCLHVCQUFPLGFBQWEsSUFBYixDQUFrQixVQUFVLFVBQVYsRUFBc0I7QUFDM0MsMkJBQU8sZUFBZSxJQUF0QjtBQUNILGlCQUZNLENBQVA7QUFHSCxhQUpNLENBQVA7QUFLSDs7Ozs7O2tCQTFDZ0IsVSIsImZpbGUiOiJ0ZXh0bGludC1ydWxlLWhlbHBlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIExJQ0VOU0UgOiBNSVRcblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBSdWxlSGVscGVyIGlzIGhlbHBlciBjbGFzcyBmb3IgdGV4dGxpbnQuXG4gKiBAY2xhc3MgUnVsZUhlbHBlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlSGVscGVyIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIFJ1bGVIZWxwZXIgd2l0aCBSdWxlQ29udGV4dCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSdWxlQ29udGV4dH0gcnVsZUNvbnRleHQgdGhlIHJ1bGVDb250ZXh0IGlzIGNvbnRleHQgb2JqZWN0IG9mIHRoZSBydWxlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJ1bGVDb250ZXh0KSB7XG4gICAgICAgIHRoaXMucnVsZUNvbnRleHQgPSBydWxlQ29udGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGFyZW50cyBvZiBub2RlLlxuICAgICAqIFRoZSBwYXJlbnQgbm9kZXMgYXJlIHJldHVybmVkIGluIG9yZGVyIGZyb20gdGhlIGNsb3Nlc3QgcGFyZW50IHRvIHRoZSBvdXRlciBvbmVzLlxuICAgICAqIHtAbGluayBub2RlfSBpcyBub3QgY29udGFpbmVkIGluIHRoZSByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7VHh0Tm9kZX0gbm9kZSB0aGUgbm9kZSBpcyBzdGFydCBwb2ludC5cbiAgICAgKiBAcmV0dXJucyB7VHh0Tm9kZVtdfVxuICAgICAqL1xuICAgIGdldFBhcmVudHMobm9kZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJlbnQpO1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIGBub2RlYCBpcyB3cmFwcGVkIGFueSBvbmUgb2Ygbm9kZSB7QGxpbmsgdHlwZXN9LlxuICAgICAqIEBwYXJhbSB7VHh0Tm9kZX0gbm9kZSBpcyB0YXJnZXQgbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHR5cGVzIGFyZSB3cmFwcGVkIHRhcmdldCBub2RlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNDaGlsZE5vZGUobm9kZSwgdHlwZXMpIHtcbiAgICAgICAgdmFyIHBhcmVudHMgPSB0aGlzLmdldFBhcmVudHMobm9kZSk7XG4gICAgICAgIHZhciBwYXJlbnRzVHlwZXMgPSBwYXJlbnRzLm1hcChmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LnR5cGU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZXMuc29tZShmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudHNUeXBlcy5zb21lKGZ1bmN0aW9uIChwYXJlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFR5cGUgPT09IHR5cGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufSJdfQ==
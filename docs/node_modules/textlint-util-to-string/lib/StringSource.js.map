{"version":3,"sources":["../src/StringSource.js"],"names":["StringSource","node","rootNode","tokenMaps","generatedString","_stringify","originalSource","raw","generatedSource","targetIndex","originalIndexFromIndex","generatedPosition","isEnd","originalPositionFromPosition","generatedIndex","hitTokenMaps","filter","tokenMap","index","generated","nextTokenMap","nextGenerated","length","hitTokenMap","outerAdjust","innerAdjust","intermediate","original","position","line","column","Error","JSON","stringify","positionToIndex","isNaN","originalIndex","indexToPosition","originalPosition","type","value","alt","title","range","parent","_getValue","undefined","isParagraphNode","isStringNode","_nodeRangeAsRelative","container","rawValue","paddingLeft","indexOf","paddingRight","originalRange","intermediateRange","addedTokenMap","textLength","push","_valueOf","children","forEach","childNode","_addTokenMap"],"mappings":"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","file":"StringSource.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport ObjectAssign from \"object-assign\";\nimport StructuredSource from \"structured-source\";\n\nexport default class StringSource {\n    constructor(node) {\n        this.rootNode = node;\n        this.tokenMaps = [];\n        this.generatedString = \"\";\n        // pre calculate\n        this._stringify(this.rootNode);\n        this.originalSource = new StructuredSource(this.rootNode.raw);\n        this.generatedSource = new StructuredSource(this.generatedString);\n        /*\n         [\n         // e.g.) **Str**\n         {\n         // original range\n         // e.g.) [0, 7] = `**Str**`\n         original : [start, end]\n         // intermediate = trim decoration from Original\n         // e.g.) [2, 5]\n         intermediate: [start, end]\n         // generated value = \"Str\"\n         // e.g.) [0, 3]\n         generated : [start, end]\n         }]\n         */\n    }\n\n    toString() {\n        return this.generatedString;\n    }\n\n    /**\n     * @deprecated use originalIndexFromIndex instead of\n     * @param targetIndex\n     */\n    originalIndexFor(targetIndex) {\n        return this.originalIndexFromIndex(targetIndex);\n    }\n\n    /**\n     * @deprecated use originalPositionFromPosition instead of\n     * @param generatedPosition\n     * @param {boolean}  isEnd - is the position end of the node?\n\n     * @returns {Object}\n     */\n    originalPositionFor(generatedPosition, isEnd) {\n        return this.originalPositionFromPosition(generatedPosition, isEnd);\n    }\n\n    /**\n     * get original index from generated index value\n     * @param {number} generatedIndex - position is a index value.\n     * @param {boolean}  isEnd - is the position end of the node?\n     * @returns {number|undefined} original\n     */\n    originalIndexFromIndex(generatedIndex, isEnd = false) {\n        let hitTokenMaps = this.tokenMaps.filter((tokenMap, index) => {\n            const generated = tokenMap.generated;\n            const nextTokenMap = this.tokenMaps[index + 1];\n            const nextGenerated = nextTokenMap ? nextTokenMap.generated : null;\n            if (nextGenerated) {\n                if (generated[0] <= generatedIndex && generatedIndex <= nextGenerated[0]) {\n                    return true;\n                }\n            } else {\n                if (generated[0] <= generatedIndex && generatedIndex <= generated[1]) {\n                    return true;\n                }\n            }\n        });\n        if (hitTokenMaps.length === 0) {\n            return;\n        }\n\n        /**\n         * **Str**ABC\n         *     |\n         *     |\n         *   generatedIndex\n         *\n         * If isEnd is true, generatedIndex is end of **Str** node.\n         * If isEnd is false, generatedIndex is index of ABC node.\n         */\n\n        const hitTokenMap = isEnd ? hitTokenMaps[0] : hitTokenMaps[hitTokenMaps.length - 1];\n        // <----------->[<------------->|text]\n        //              ^        ^\n        //   position-generated  intermediate-origin\n\n        // <-------------->[<------------->|text]\n        //       |         |\n        //  outer adjust   _\n        //            inner adjust = 1\n        const outerAdjust = generatedIndex - hitTokenMap.generated[0];\n        const innerAdjust = hitTokenMap.intermediate[0] - hitTokenMap.original[0];\n        return outerAdjust + innerAdjust + hitTokenMap.original[0];\n    }\n\n    /**\n     * get original position from generated position\n     * @param {object} position\n     * @param {boolean}  isEnd - is the position end of the node?\n     * @returns {object} original position\n     */\n    originalPositionFromPosition(position, isEnd = false) {\n        if (typeof position.line === \"undefined\" || typeof position.column === \"undefined\") {\n            throw new Error(\"position.{line, column} should not undefined: \" + JSON.stringify(position));\n        }\n        const generatedIndex = this.generatedSource.positionToIndex(position);\n        if (isNaN(generatedIndex)) {\n            // Not Found\n            return;\n        }\n        const originalIndex = this.originalIndexFromIndex(generatedIndex, isEnd);\n        return this.originalSource.indexToPosition(originalIndex, isEnd);\n    }\n\n    /**\n     * get original index from generated position\n     * @param {object} generatedPosition\n     * @param {boolean}  isEnd - is the position end of the node?\n     * @returns {number} original index\n     */\n    originalIndexFromPosition(generatedPosition, isEnd = false) {\n        const originalPosition = this.originalPositionFromPosition(generatedPosition);\n        return this.originalSource.positionToIndex(originalPosition, isEnd);\n    }\n\n    /**\n     * get original position from generated index\n     * @param {number} generatedIndex\n     * @param {boolean} isEnd - is the position end of the node?\n     * @return {object} original position\n     */\n    originalPositionFromIndex(generatedIndex, isEnd = false) {\n        let originalIndex = this.originalIndexFromIndex(generatedIndex);\n        return this.originalSource.indexToPosition(originalIndex, isEnd);\n    }\n\n\n    isParagraphNode(node) {\n        return node.type === \"Paragraph\";\n    }\n\n    isStringNode(node) {\n        return node.type === \"Str\";\n    }\n\n    /**\n     *\n     * @param node\n     * @returns {string|undefined}\n     * @private\n     */\n    _getValue(node) {\n        if (node.value) {\n            return node.value;\n        } else if (node.alt) {\n            return node.alt;\n        } else if (node.title) {\n            // See https://github.com/azu/textlint-rule-sentence-length/issues/6\n            if (node.type === \"Link\") {\n                return;\n            }\n            return node.title;\n        }\n    }\n\n    _nodeRangeAsRelative(node) {\n        // relative from root\n        return [\n            node.range[0] - this.rootNode.range[0],\n            node.range[1] - this.rootNode.range[0]\n        ]\n    }\n\n    _valueOf(node, parent) {\n        if (!node) {\n            return;\n        }\n\n\n        // [padding][value][padding]\n        // =>\n        // [value][value][value]\n        const value = this._getValue(node);\n        if (!value) {\n            return;\n        }\n        if (parent === null || parent === undefined) {\n            return;\n        }\n        // <p><Str /></p>\n        if (this.isParagraphNode(parent) && this.isStringNode(node)) {\n            return {\n                original: this._nodeRangeAsRelative(node),\n                intermediate: this._nodeRangeAsRelative(node),\n                value: value\n            };\n        }\n        // <p><code>code</code></p>\n        // => container is <p>\n        // <p><strong><Str /></strong></p>\n        // => container is <strong>\n        let container = this.isParagraphNode(parent) ? node : parent;\n        let rawValue = container.raw;\n        // avoid match ! with ![\n        // TODO: indexOf(value, 1) 1 is unexpected ...\n        let paddingLeft = rawValue.indexOf(value, 1) === -1 ? 0 : rawValue.indexOf(value, 1);\n        let paddingRight = rawValue.length - (paddingLeft + value.length);\n        // original range should be relative value from rootNode\n        let originalRange = this._nodeRangeAsRelative(container);\n        let intermediateRange = [\n            originalRange[0] + paddingLeft,\n            originalRange[1] - paddingRight\n        ];\n        return {\n            original: originalRange,\n            intermediate: intermediateRange,\n            value: value\n        };\n\n    }\n\n    _addTokenMap(tokenMap) {\n        if (tokenMap == null) {\n            return;\n        }\n        let addedTokenMap = ObjectAssign({}, tokenMap);\n        if (this.tokenMaps.length === 0) {\n            let textLength = addedTokenMap.intermediate[1] - addedTokenMap.intermediate[0];\n            addedTokenMap[\"generated\"] = [0, textLength];\n        } else {\n            let textLength = addedTokenMap.intermediate[1] - addedTokenMap.intermediate[0];\n            addedTokenMap[\"generated\"] = [this.generatedString.length, this.generatedString.length + textLength];\n        }\n        this.generatedString += tokenMap.value;\n        this.tokenMaps.push(addedTokenMap);\n    }\n\n    /**\n     * Compute text content of a node.  If the node itself\n     * does not expose plain-text fields, `toString` will\n     * recursivly try its children.\n     *\n     * @param {Node} node - Node to transform to a string.\n     * @param {Node} [parent] - Parent Node of the `node`.\n     */\n    _stringify(node, parent) {\n        let value = this._valueOf(node, parent);\n        if (value) {\n            return value;\n        }\n        if (!node.children) {\n            return;\n        }\n        node.children.forEach((childNode) => {\n            let tokenMap = this._stringify(childNode, node);\n            if (tokenMap) {\n                this._addTokenMap(tokenMap);\n            }\n        });\n    }\n}\n"]}
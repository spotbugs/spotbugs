// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _objectAssign = require("object-assign");

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _structuredSource = require("structured-source");

var _structuredSource2 = _interopRequireDefault(_structuredSource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StringSource = function () {
    function StringSource(node) {
        _classCallCheck(this, StringSource);

        this.rootNode = node;
        this.tokenMaps = [];
        this.generatedString = "";
        // pre calculate
        this._stringify(this.rootNode);
        this.originalSource = new _structuredSource2.default(this.rootNode.raw);
        this.generatedSource = new _structuredSource2.default(this.generatedString);
        /*
         [
         // e.g.) **Str**
         {
         // original range
         // e.g.) [0, 7] = `**Str**`
         original : [start, end]
         // intermediate = trim decoration from Original
         // e.g.) [2, 5]
         intermediate: [start, end]
         // generated value = "Str"
         // e.g.) [0, 3]
         generated : [start, end]
         }]
         */
    }

    _createClass(StringSource, [{
        key: "toString",
        value: function toString() {
            return this.generatedString;
        }

        /**
         * @deprecated use originalIndexFromIndex instead of
         * @param targetIndex
         */

    }, {
        key: "originalIndexFor",
        value: function originalIndexFor(targetIndex) {
            return this.originalIndexFromIndex(targetIndex);
        }

        /**
         * @deprecated use originalPositionFromPosition instead of
         * @param generatedPosition
         * @param {boolean}  isEnd - is the position end of the node?
          * @returns {Object}
         */

    }, {
        key: "originalPositionFor",
        value: function originalPositionFor(generatedPosition, isEnd) {
            return this.originalPositionFromPosition(generatedPosition, isEnd);
        }

        /**
         * get original index from generated index value
         * @param {number} generatedIndex - position is a index value.
         * @param {boolean}  isEnd - is the position end of the node?
         * @returns {number|undefined} original
         */

    }, {
        key: "originalIndexFromIndex",
        value: function originalIndexFromIndex(generatedIndex) {
            var _this = this;

            var isEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            var hitTokenMaps = this.tokenMaps.filter(function (tokenMap, index) {
                var generated = tokenMap.generated;
                var nextTokenMap = _this.tokenMaps[index + 1];
                var nextGenerated = nextTokenMap ? nextTokenMap.generated : null;
                if (nextGenerated) {
                    if (generated[0] <= generatedIndex && generatedIndex <= nextGenerated[0]) {
                        return true;
                    }
                } else {
                    if (generated[0] <= generatedIndex && generatedIndex <= generated[1]) {
                        return true;
                    }
                }
            });
            if (hitTokenMaps.length === 0) {
                return;
            }

            /**
             * **Str**ABC
             *     |
             *     |
             *   generatedIndex
             *
             * If isEnd is true, generatedIndex is end of **Str** node.
             * If isEnd is false, generatedIndex is index of ABC node.
             */

            var hitTokenMap = isEnd ? hitTokenMaps[0] : hitTokenMaps[hitTokenMaps.length - 1];
            // <----------->[<------------->|text]
            //              ^        ^
            //   position-generated  intermediate-origin

            // <-------------->[<------------->|text]
            //       |         |
            //  outer adjust   _
            //            inner adjust = 1
            var outerAdjust = generatedIndex - hitTokenMap.generated[0];
            var innerAdjust = hitTokenMap.intermediate[0] - hitTokenMap.original[0];
            return outerAdjust + innerAdjust + hitTokenMap.original[0];
        }

        /**
         * get original position from generated position
         * @param {object} position
         * @param {boolean}  isEnd - is the position end of the node?
         * @returns {object} original position
         */

    }, {
        key: "originalPositionFromPosition",
        value: function originalPositionFromPosition(position) {
            var isEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            if (typeof position.line === "undefined" || typeof position.column === "undefined") {
                throw new Error("position.{line, column} should not undefined: " + JSON.stringify(position));
            }
            var generatedIndex = this.generatedSource.positionToIndex(position);
            if (isNaN(generatedIndex)) {
                // Not Found
                return;
            }
            var originalIndex = this.originalIndexFromIndex(generatedIndex, isEnd);
            return this.originalSource.indexToPosition(originalIndex, isEnd);
        }

        /**
         * get original index from generated position
         * @param {object} generatedPosition
         * @param {boolean}  isEnd - is the position end of the node?
         * @returns {number} original index
         */

    }, {
        key: "originalIndexFromPosition",
        value: function originalIndexFromPosition(generatedPosition) {
            var isEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            var originalPosition = this.originalPositionFromPosition(generatedPosition);
            return this.originalSource.positionToIndex(originalPosition, isEnd);
        }

        /**
         * get original position from generated index
         * @param {number} generatedIndex
         * @param {boolean} isEnd - is the position end of the node?
         * @return {object} original position
         */

    }, {
        key: "originalPositionFromIndex",
        value: function originalPositionFromIndex(generatedIndex) {
            var isEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            var originalIndex = this.originalIndexFromIndex(generatedIndex);
            return this.originalSource.indexToPosition(originalIndex, isEnd);
        }
    }, {
        key: "isParagraphNode",
        value: function isParagraphNode(node) {
            return node.type === "Paragraph";
        }
    }, {
        key: "isStringNode",
        value: function isStringNode(node) {
            return node.type === "Str";
        }

        /**
         *
         * @param node
         * @returns {string|undefined}
         * @private
         */

    }, {
        key: "_getValue",
        value: function _getValue(node) {
            if (node.value) {
                return node.value;
            } else if (node.alt) {
                return node.alt;
            } else if (node.title) {
                // See https://github.com/azu/textlint-rule-sentence-length/issues/6
                if (node.type === "Link") {
                    return;
                }
                return node.title;
            }
        }
    }, {
        key: "_nodeRangeAsRelative",
        value: function _nodeRangeAsRelative(node) {
            // relative from root
            return [node.range[0] - this.rootNode.range[0], node.range[1] - this.rootNode.range[0]];
        }
    }, {
        key: "_valueOf",
        value: function _valueOf(node, parent) {
            if (!node) {
                return;
            }

            // [padding][value][padding]
            // =>
            // [value][value][value]
            var value = this._getValue(node);
            if (!value) {
                return;
            }
            if (parent === null || parent === undefined) {
                return;
            }
            // <p><Str /></p>
            if (this.isParagraphNode(parent) && this.isStringNode(node)) {
                return {
                    original: this._nodeRangeAsRelative(node),
                    intermediate: this._nodeRangeAsRelative(node),
                    value: value
                };
            }
            // <p><code>code</code></p>
            // => container is <p>
            // <p><strong><Str /></strong></p>
            // => container is <strong>
            var container = this.isParagraphNode(parent) ? node : parent;
            var rawValue = container.raw;
            // avoid match ! with ![
            // TODO: indexOf(value, 1) 1 is unexpected ...
            var paddingLeft = rawValue.indexOf(value, 1) === -1 ? 0 : rawValue.indexOf(value, 1);
            var paddingRight = rawValue.length - (paddingLeft + value.length);
            // original range should be relative value from rootNode
            var originalRange = this._nodeRangeAsRelative(container);
            var intermediateRange = [originalRange[0] + paddingLeft, originalRange[1] - paddingRight];
            return {
                original: originalRange,
                intermediate: intermediateRange,
                value: value
            };
        }
    }, {
        key: "_addTokenMap",
        value: function _addTokenMap(tokenMap) {
            if (tokenMap == null) {
                return;
            }
            var addedTokenMap = (0, _objectAssign2.default)({}, tokenMap);
            if (this.tokenMaps.length === 0) {
                var textLength = addedTokenMap.intermediate[1] - addedTokenMap.intermediate[0];
                addedTokenMap["generated"] = [0, textLength];
            } else {
                var _textLength = addedTokenMap.intermediate[1] - addedTokenMap.intermediate[0];
                addedTokenMap["generated"] = [this.generatedString.length, this.generatedString.length + _textLength];
            }
            this.generatedString += tokenMap.value;
            this.tokenMaps.push(addedTokenMap);
        }

        /**
         * Compute text content of a node.  If the node itself
         * does not expose plain-text fields, `toString` will
         * recursivly try its children.
         *
         * @param {Node} node - Node to transform to a string.
         * @param {Node} [parent] - Parent Node of the `node`.
         */

    }, {
        key: "_stringify",
        value: function _stringify(node, parent) {
            var _this2 = this;

            var value = this._valueOf(node, parent);
            if (value) {
                return value;
            }
            if (!node.children) {
                return;
            }
            node.children.forEach(function (childNode) {
                var tokenMap = _this2._stringify(childNode, node);
                if (tokenMap) {
                    _this2._addTokenMap(tokenMap);
                }
            });
        }
    }]);

    return StringSource;
}();

exports.default = StringSource;
//# sourceMappingURL=StringSource.js.map
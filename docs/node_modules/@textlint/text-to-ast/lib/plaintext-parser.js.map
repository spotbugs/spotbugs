{"version":3,"sources":["../src/plaintext-parser.js"],"names":["Syntax","require","LINEBREAKE_MARK","parseLine","lineText","lineNumber","startIndex","type","Str","raw","value","range","length","loc","start","line","column","end","createEndedBRNode","prevNode","Break","createBRNode","createParagraph","nodes","firstNode","lastNode","Paragraph","map","node","join","children","parse","text","textLineByLine","split","lastLineIndex","isLasEmptytLine","index","isEmptyLine","reduce","result","currentLine","emptyBreakNode","push","strNode","paragraph","breakNode","Document","module","exports"],"mappings":"AAAA;AACA;;AACA,IAAMA,SAASC,QAAQ,oBAAR,CAAf;AACA,IAAMC,kBAAkB,QAAxB;AACA,SAASC,SAAT,CAAmBC,QAAnB,EAA6BC,UAA7B,EAAyCC,UAAzC,EAAqD;AACjD;AACA;AACA,WAAO;AACHC,cAAMP,OAAOQ,GADV;AAEHC,aAAKL,QAFF;AAGHM,eAAON,QAHJ;AAIHO,eAAO,CAACL,UAAD,EAAaA,aAAaF,SAASQ,MAAnC,CAJJ;AAKHC,aAAK;AACDC,mBAAO;AACHC,sBAAMV,UADH;AAEHW,wBAAQ;AAFL,aADN;AAKDC,iBAAK;AACDF,sBAAMV,UADL;AAEDW,wBAAQZ,SAASQ;AAFhB;AALJ;AALF,KAAP;AAgBH;AACD;;;;AAIA,SAASM,iBAAT,CAA2BC,QAA3B,EAAqC;AACjC,WAAO;AACHZ,cAAMP,OAAOoB,KADV;AAEHX,aAAK,IAFF;AAGHC,eAAO,IAHJ;AAIHC,eAAO,CAACQ,SAASR,KAAT,CAAe,CAAf,CAAD,EAAoBQ,SAASR,KAAT,CAAe,CAAf,IAAoB,CAAxC,CAJJ;AAKHE,aAAK;AACDC,mBAAO;AACHC,sBAAMI,SAASN,GAAT,CAAaI,GAAb,CAAiBF,IADpB;AAEHC,wBAAQG,SAASN,GAAT,CAAaI,GAAb,CAAiBD;AAFtB,aADN;AAKDC,iBAAK;AACDF,sBAAMI,SAASN,GAAT,CAAaI,GAAb,CAAiBF,IADtB;AAEDC,wBAAQG,SAASN,GAAT,CAAaI,GAAb,CAAiBD,MAAjB,GAA0B;AAFjC;AALJ;AALF,KAAP;AAgBH;AACD;;;AAGA,SAASK,YAAT,CAAsBhB,UAAtB,EAAkCC,UAAlC,EAA8C;AAC1C,WAAO;AACHC,cAAMP,OAAOoB,KADV;AAEHX,aAAK,IAFF;AAGHE,eAAO,CAACL,UAAD,EAAaA,aAAa,CAA1B,CAHJ;AAIHO,aAAK;AACDC,mBAAO;AACHC,sBAAMV,UADH;AAEHW,wBAAQ;AAFL,aADN;AAKDC,iBAAK;AACDF,sBAAMV,UADL;AAEDW,wBAAQ;AAFP;AALJ;AAJF,KAAP;AAeH;AACD;;;;;AAKA,SAASM,eAAT,CAAyBC,KAAzB,EAAgC;AAC5B,QAAMC,YAAYD,MAAM,CAAN,CAAlB;AACA,QAAME,WAAWF,MAAMA,MAAMX,MAAN,GAAe,CAArB,CAAjB;AACA,WAAO;AACHL,cAAMP,OAAO0B,SADV;AAEHjB,aAAKc,MACAI,GADA,CACI,UAASC,IAAT,EAAe;AAChB,mBAAOA,KAAKnB,GAAZ;AACH,SAHA,EAIAoB,IAJA,CAIK,EAJL,CAFF;AAOHlB,eAAO,CAACa,UAAUb,KAAV,CAAgB,CAAhB,CAAD,EAAqBc,SAASd,KAAT,CAAe,CAAf,CAArB,CAPJ;AAQHE,aAAK;AACDC,mBAAO;AACHC,sBAAMS,UAAUX,GAAV,CAAcC,KAAd,CAAoBC,IADvB;AAEHC,wBAAQQ,UAAUX,GAAV,CAAcC,KAAd,CAAoBE;AAFzB,aADN;AAKDC,iBAAK;AACDF,sBAAMU,SAASZ,GAAT,CAAaI,GAAb,CAAiBF,IADtB;AAEDC,wBAAQS,SAASZ,GAAT,CAAaI,GAAb,CAAiBD;AAFxB;AALJ,SARF;AAkBHc,kBAAUP;AAlBP,KAAP;AAoBH;;AAED;;;;;AAKA,SAASQ,KAAT,CAAeC,IAAf,EAAqB;AACjB,QAAMC,iBAAiBD,KAAKE,KAAL,CAAWhC,eAAX,CAAvB;AACA;AACA,QAAII,aAAa,CAAjB;AACA,QAAM6B,gBAAgBF,eAAerB,MAAf,GAAwB,CAA9C;AACA,QAAMwB,kBAAkB,SAAlBA,eAAkB,CAACrB,IAAD,EAAOsB,KAAP,EAAiB;AACrC,eAAOA,UAAUF,aAAV,IAA2BpB,SAAS,EAA3C;AACH,KAFD;AAGA,QAAMuB,cAAc,SAAdA,WAAc,CAACvB,IAAD,EAAOsB,KAAP,EAAiB;AACjC,eAAOA,UAAUF,aAAV,IAA2BpB,SAAS,EAA3C;AACH,KAFD;AAGA,QAAMe,WAAWG,eAAeM,MAAf,CAAsB,UAASC,MAAT,EAAiBC,WAAjB,EAA8BJ,KAA9B,EAAqC;AACxE,YAAMhC,aAAagC,QAAQ,CAA3B;AACA,YAAID,gBAAgBK,WAAhB,EAA6BJ,KAA7B,CAAJ,EAAyC;AACrC,mBAAOG,MAAP;AACH;AACD;AACA,YAAIF,YAAYG,WAAZ,EAAyBJ,KAAzB,CAAJ,EAAqC;AACjC,gBAAMK,iBAAiBrB,aAAahB,UAAb,EAAyBC,UAAzB,CAAvB;AACAA,0BAAcoC,eAAejC,GAAf,CAAmBG,MAAjC;AACA4B,mBAAOG,IAAP,CAAYD,cAAZ;AACA,mBAAOF,MAAP;AACH;;AAED;AACA,YAAMI,UAAUzC,UAAUsC,WAAV,EAAuBpC,UAAvB,EAAmCC,UAAnC,CAAhB;AACA,YAAMuC,YAAYvB,gBAAgB,CAACsB,OAAD,CAAhB,CAAlB;AACAtC,sBAAcuC,UAAUpC,GAAV,CAAcG,MAA5B;AACA4B,eAAOG,IAAP,CAAYE,SAAZ;AACA,YAAIR,UAAUF,aAAd,EAA6B;AACzB,gBAAMW,YAAY5B,kBAAkB2B,SAAlB,CAAlB;AACAvC,0BAAcwC,UAAUrC,GAAV,CAAcG,MAA5B;AACA4B,mBAAOG,IAAP,CAAYG,SAAZ;AACH;AACD,eAAON,MAAP;AACH,KAxBgB,EAwBd,EAxBc,CAAjB;AAyBA,WAAO;AACHjC,cAAMP,OAAO+C,QADV;AAEHtC,aAAKuB,IAFF;AAGHrB,eAAO,CAAC,CAAD,EAAIqB,KAAKpB,MAAT,CAHJ;AAIHC,aAAK;AACDC,mBAAO;AACHC,sBAAM,CADH;AAEHC,wBAAQ;AAFL,aADN;AAKDC,iBAAK;AACDF,sBAAMkB,eAAerB,MADpB;AAEDI,wBAAQiB,eAAeA,eAAerB,MAAf,GAAwB,CAAvC,EAA0CA;AAFjD;AALJ,SAJF;AAcHkB;AAdG,KAAP;AAgBH;AACDkB,OAAOC,OAAP,GAAiBlB,KAAjB","file":"plaintext-parser.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst Syntax = require(\"./plaintext-syntax\");\nconst LINEBREAKE_MARK = /\\r?\\n/g;\nfunction parseLine(lineText, lineNumber, startIndex) {\n    // Inline Node have `value`. It it not part of TxtNode.\n    // TODO: https://github.com/textlint/textlint/issues/141\n    return {\n        type: Syntax.Str,\n        raw: lineText,\n        value: lineText,\n        range: [startIndex, startIndex + lineText.length],\n        loc: {\n            start: {\n                line: lineNumber,\n                column: 0\n            },\n            end: {\n                line: lineNumber,\n                column: lineText.length\n            }\n        }\n    };\n}\n/**\n * create BreakNode next to StrNode\n * @param {TxtNode} prevNode previous node from BreakNode\n */\nfunction createEndedBRNode(prevNode) {\n    return {\n        type: Syntax.Break,\n        raw: \"\\n\",\n        value: \"\\n\",\n        range: [prevNode.range[1], prevNode.range[1] + 1],\n        loc: {\n            start: {\n                line: prevNode.loc.end.line,\n                column: prevNode.loc.end.column\n            },\n            end: {\n                line: prevNode.loc.end.line,\n                column: prevNode.loc.end.column + 1\n            }\n        }\n    };\n}\n/**\n * create BreakNode next to StrNode\n */\nfunction createBRNode(lineNumber, startIndex) {\n    return {\n        type: Syntax.Break,\n        raw: \"\\n\",\n        range: [startIndex, startIndex + 1],\n        loc: {\n            start: {\n                line: lineNumber,\n                column: 0\n            },\n            end: {\n                line: lineNumber,\n                column: 1\n            }\n        }\n    };\n}\n/**\n * create paragraph node from TxtNodes\n * @param {[TxtNode]} nodes\n * @returns {TxtNode} Paragraph node\n */\nfunction createParagraph(nodes) {\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    return {\n        type: Syntax.Paragraph,\n        raw: nodes\n            .map(function(node) {\n                return node.raw;\n            })\n            .join(\"\"),\n        range: [firstNode.range[0], lastNode.range[1]],\n        loc: {\n            start: {\n                line: firstNode.loc.start.line,\n                column: firstNode.loc.start.column\n            },\n            end: {\n                line: lastNode.loc.end.line,\n                column: lastNode.loc.end.column\n            }\n        },\n        children: nodes\n    };\n}\n\n/**\n * parse text and return ast mapped location info.\n * @param {string} text\n * @returns {TxtNode}\n */\nfunction parse(text) {\n    const textLineByLine = text.split(LINEBREAKE_MARK);\n    // it should be alternately Str and Break\n    let startIndex = 0;\n    const lastLineIndex = textLineByLine.length - 1;\n    const isLasEmptytLine = (line, index) => {\n        return index === lastLineIndex && line === \"\";\n    };\n    const isEmptyLine = (line, index) => {\n        return index !== lastLineIndex && line === \"\";\n    };\n    const children = textLineByLine.reduce(function(result, currentLine, index) {\n        const lineNumber = index + 1;\n        if (isLasEmptytLine(currentLine, index)) {\n            return result;\n        }\n        // \\n\n        if (isEmptyLine(currentLine, index)) {\n            const emptyBreakNode = createBRNode(lineNumber, startIndex);\n            startIndex += emptyBreakNode.raw.length;\n            result.push(emptyBreakNode);\n            return result;\n        }\n\n        // (Paragraph > Str) -> Br?\n        const strNode = parseLine(currentLine, lineNumber, startIndex);\n        const paragraph = createParagraph([strNode]);\n        startIndex += paragraph.raw.length;\n        result.push(paragraph);\n        if (index !== lastLineIndex) {\n            const breakNode = createEndedBRNode(paragraph);\n            startIndex += breakNode.raw.length;\n            result.push(breakNode);\n        }\n        return result;\n    }, []);\n    return {\n        type: Syntax.Document,\n        raw: text,\n        range: [0, text.length],\n        loc: {\n            start: {\n                line: 1,\n                column: 0\n            },\n            end: {\n                line: textLineByLine.length,\n                column: textLineByLine[textLineByLine.length - 1].length\n            }\n        },\n        children\n    };\n}\nmodule.exports = parse;\n"]}
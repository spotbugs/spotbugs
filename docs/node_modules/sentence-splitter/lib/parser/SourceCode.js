"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var StructureSource = require("structured-source");
var SourceCode = /** @class */ (function () {
    function SourceCode(input) {
        this.index = 0;
        this.contexts = [];
        this.contextRanges = [];
        if (typeof input === "string") {
            this.textCharacters = input.split("");
            this.source = new StructureSource(input);
            this.startOffset = 0;
            this.firstChildPadding = 0;
        }
        else {
            this.sourceNode = input;
            // When pass AST, fist node may be >=
            // Preserve it as `startOffset`
            this.startOffset = this.sourceNode.range[0];
            // start index is startOffset
            this.index = this.startOffset;
            // before line count of Paragraph node
            var lineBreaks = Array.from(new Array(this.sourceNode.loc.start.line - 1)).fill("\n");
            // filled with dummy text
            var offset = Array.from(new Array(this.startOffset - lineBreaks.length)).fill("âˆ¯");
            this.textCharacters = offset.concat(lineBreaks, input.raw.split(""));
            this.source = new StructureSource(this.textCharacters.join(""));
            if (this.sourceNode.children[0]) {
                // Header Node's children does not start with index 0
                // Example: # Header
                // It firstChildPadding is `2`
                this.firstChildPadding = this.sourceNode.children[0].range[0] - this.startOffset;
            }
            else {
                this.firstChildPadding = 0;
            }
        }
    }
    SourceCode.prototype.markContextRange = function (range) {
        this.contextRanges.push(range);
    };
    SourceCode.prototype.isInContextRange = function () {
        var offset = this.offset;
        return this.contextRanges.some(function (range) {
            return range[0] <= offset && offset < range[1];
        });
    };
    SourceCode.prototype.enterContext = function (context) {
        this.contexts.push(context);
    };
    SourceCode.prototype.isInContext = function (context) {
        if (!context) {
            return this.contexts.length > 0;
        }
        return this.contexts.some(function (targetContext) { return targetContext === context; });
    };
    SourceCode.prototype.leaveContext = function (context) {
        var index = this.contexts.lastIndexOf(context);
        if (index !== -1) {
            this.contexts.splice(index, 1);
        }
    };
    Object.defineProperty(SourceCode.prototype, "offset", {
        /**
         * Return current offset value
         * @returns {number}
         */
        get: function () {
            return this.index + this.firstChildPadding;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Return current position object.
     * It includes line, column, offset.
     */
    SourceCode.prototype.now = function () {
        var indexWithChildrenOffset = this.offset;
        var position = this.source.indexToPosition(indexWithChildrenOffset);
        return {
            line: position.line,
            column: position.column,
            offset: indexWithChildrenOffset
        };
    };
    Object.defineProperty(SourceCode.prototype, "hasEnd", {
        /**
         * Return true, no more read char
         */
        get: function () {
            return this.read() === false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * read char
     * if can not read, return empty string
     * @returns {string}
     */
    SourceCode.prototype.read = function (over) {
        if (over === void 0) { over = 0; }
        var index = this.offset + over;
        if (index < this.startOffset) {
            return false;
        }
        if (0 <= index && index < this.textCharacters.length) {
            return this.textCharacters[index];
        }
        return false;
    };
    /**
     * read node
     * if can not read, return empty string
     * @returns {node}
     */
    SourceCode.prototype.readNode = function (over) {
        if (over === void 0) { over = 0; }
        if (!this.sourceNode) {
            return false;
        }
        var index = this.offset + over;
        if (index < this.startOffset) {
            return false;
        }
        var matchNodeList = this.sourceNode.children.filter(function (node) {
            // <p>[node]</p>
            //         ^
            //        range[1]
            // `< range[1]` prevent infinity loop
            // https://github.com/azu/sentence-splitter/issues/9
            return node.range[0] <= index && index < node.range[1];
        });
        if (matchNodeList.length > 0) {
            // last match
            // because, range is overlap two nodes
            return matchNodeList[matchNodeList.length - 1];
        }
        return false;
    };
    /**
     * Increment current index
     */
    SourceCode.prototype.peek = function () {
        this.index += 1;
    };
    /**
     * Increment node range
     */
    SourceCode.prototype.peekNode = function (node) {
        this.index += node.range[1] - node.range[0];
    };
    /**
     * Seek and Peek
     */
    SourceCode.prototype.seekNext = function (parser) {
        var startPosition = this.now();
        parser.seek(this);
        var endPosition = this.now();
        var value = this.sliceRange(startPosition.offset, endPosition.offset);
        return {
            value: value,
            startPosition: startPosition,
            endPosition: endPosition
        };
    };
    /**
     * Slice text form the range.
     * @param {number} start
     * @param {number} end
     * @returns {string}
     */
    SourceCode.prototype.sliceRange = function (start, end) {
        return this.textCharacters.slice(start, end).join("");
    };
    return SourceCode;
}());
exports.SourceCode = SourceCode;
//# sourceMappingURL=SourceCode.js.map
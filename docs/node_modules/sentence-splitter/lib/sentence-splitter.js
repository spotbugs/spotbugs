// LICENSE : MIT
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ast_node_types_1 = require("@textlint/ast-node-types");
var SourceCode_1 = require("./parser/SourceCode");
var NewLineParser_1 = require("./parser/NewLineParser");
var SpaceParser_1 = require("./parser/SpaceParser");
var SeparatorParser_1 = require("./parser/SeparatorParser");
var AnyValueParser_1 = require("./parser/AnyValueParser");
var AbbrMarker_1 = require("./parser/AbbrMarker");
var PairMaker_1 = require("./parser/PairMaker");
var logger_1 = require("./logger");
exports.Syntax = {
    WhiteSpace: "WhiteSpace",
    Punctuation: "Punctuation",
    Sentence: "Sentence",
    Str: "Str"
};
var SplitParser = /** @class */ (function () {
    function SplitParser(text) {
        this.nodeList = [];
        this.results = [];
        this.source = new SourceCode_1.SourceCode(text);
    }
    Object.defineProperty(SplitParser.prototype, "current", {
        get: function () {
            return this.nodeList[this.nodeList.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    SplitParser.prototype.pushNodeToCurrent = function (node) {
        var current = this.current;
        if (current) {
            current.children.push(node);
        }
        else {
            // Under the root
            this.results.push(node);
        }
    };
    // open with ParentNode
    SplitParser.prototype.open = function (parentNode) {
        this.nodeList.push(parentNode);
    };
    SplitParser.prototype.isOpened = function () {
        return this.nodeList.length > 0;
    };
    SplitParser.prototype.nextLine = function (parser) {
        var _a = this.source.seekNext(parser), value = _a.value, startPosition = _a.startPosition, endPosition = _a.endPosition;
        this.pushNodeToCurrent(createWhiteSpaceNode(value, startPosition, endPosition));
        return endPosition;
    };
    SplitParser.prototype.nextSpace = function (parser) {
        var _a = this.source.seekNext(parser), value = _a.value, startPosition = _a.startPosition, endPosition = _a.endPosition;
        this.pushNodeToCurrent(createNode("WhiteSpace", value, startPosition, endPosition));
    };
    SplitParser.prototype.nextValue = function (parser) {
        var _a = this.source.seekNext(parser), value = _a.value, startPosition = _a.startPosition, endPosition = _a.endPosition;
        this.pushNodeToCurrent(createTextNode(value, startPosition, endPosition));
    };
    // close current Node and remove it from list
    SplitParser.prototype.close = function (parser) {
        var _a = this.source.seekNext(parser), value = _a.value, startPosition = _a.startPosition, endPosition = _a.endPosition;
        if (startPosition.offset !== endPosition.offset) {
            this.pushNodeToCurrent(createPunctuationNode(value, startPosition, endPosition));
        }
        var currentNode = this.nodeList.pop();
        if (!currentNode) {
            return;
        }
        if (currentNode.children.length === 0) {
            return;
        }
        var firstChildNode = currentNode.children[0];
        var endNow = this.source.now();
        currentNode.loc = {
            start: firstChildNode.loc.start,
            end: nowToLoc(endNow)
        };
        var rawValue = this.source.sliceRange(firstChildNode.range[0], endNow.offset);
        currentNode.range = [firstChildNode.range[0], endNow.offset];
        currentNode.raw = rawValue;
        this.results.push(currentNode);
    };
    SplitParser.prototype.toList = function () {
        return this.results;
    };
    return SplitParser;
}());
exports.SplitParser = SplitParser;
/**
 * split `text` into Sentence nodes
 */
function split(text) {
    var newLine = new NewLineParser_1.NewLineParser();
    var space = new SpaceParser_1.SpaceParser();
    var separator = new SeparatorParser_1.SeparatorParser();
    var abbrMarker = new AbbrMarker_1.AbbrMarker();
    var pairMaker = new PairMaker_1.PairMaker();
    // anyValueParser has multiple parser and markers.
    // anyValueParse eat any value if it reach to other value.
    var anyValueParser = new AnyValueParser_1.AnyValueParser({
        parsers: [newLine, separator],
        markers: [abbrMarker, pairMaker]
    });
    var splitParser = new SplitParser(text);
    var sourceCode = splitParser.source;
    while (!sourceCode.hasEnd) {
        if (newLine.test(sourceCode)) {
            splitParser.nextLine(newLine);
        }
        else if (space.test(sourceCode)) {
            // Add WhiteSpace
            splitParser.nextSpace(space);
        }
        else if (separator.test(sourceCode)) {
            splitParser.close(separator);
        }
        else {
            if (!splitParser.isOpened()) {
                splitParser.open(createEmptySentenceNode());
            }
            splitParser.nextValue(anyValueParser);
        }
    }
    splitParser.close(space);
    return splitParser.toList();
}
exports.split = split;
/**
 * Convert Paragraph Node to Paragraph node that convert children to Sentence node
 * This Node is based on TxtAST.
 * See https://github.com/textlint/textlint/blob/master/docs/txtnode.md
 */
function splitAST(paragraphNode) {
    var newLine = new NewLineParser_1.NewLineParser();
    var space = new SpaceParser_1.SpaceParser();
    var separator = new SeparatorParser_1.SeparatorParser();
    var abbrMarker = new AbbrMarker_1.AbbrMarker();
    var pairMaker = new PairMaker_1.PairMaker();
    var anyValue = new AnyValueParser_1.AnyValueParser({
        parsers: [newLine, separator],
        markers: [abbrMarker, pairMaker]
    });
    var splitParser = new SplitParser(paragraphNode);
    var sourceCode = splitParser.source;
    while (!sourceCode.hasEnd) {
        var currentNode = sourceCode.readNode();
        if (!currentNode) {
            break;
        }
        if (currentNode.type === ast_node_types_1.ASTNodeTypes.Str) {
            if (space.test(sourceCode)) {
                logger_1.debugLog("space");
                splitParser.nextSpace(space);
            }
            else if (separator.test(sourceCode)) {
                logger_1.debugLog("separator");
                splitParser.close(separator);
            }
            else if (newLine.test(sourceCode)) {
                logger_1.debugLog("newline");
                splitParser.nextLine(newLine);
            }
            else {
                if (!splitParser.isOpened()) {
                    logger_1.debugLog("open -> createEmptySentenceNode()");
                    splitParser.open(createEmptySentenceNode());
                }
                splitParser.nextValue(anyValue);
            }
        }
        else {
            if (!splitParser.isOpened()) {
                splitParser.open(createEmptySentenceNode());
            }
            splitParser.pushNodeToCurrent(currentNode);
            sourceCode.peekNode(currentNode);
        }
    }
    // It follow some text that is not ended with period.
    // TODO: space is correct?
    splitParser.close(space);
    return __assign({}, paragraphNode, { children: splitParser.toList() });
}
exports.splitAST = splitAST;
/**
 * WhiteSpace is space or linebreak
 */
function createWhiteSpaceNode(text, startPosition, endPosition) {
    return createNode("WhiteSpace", text, startPosition, endPosition);
}
exports.createWhiteSpaceNode = createWhiteSpaceNode;
function createPunctuationNode(text, startPosition, endPosition) {
    return createNode("Punctuation", text, startPosition, endPosition);
}
exports.createPunctuationNode = createPunctuationNode;
function createTextNode(text, startPosition, endPosition) {
    return createNode("Str", text, startPosition, endPosition);
}
exports.createTextNode = createTextNode;
function createEmptySentenceNode() {
    return {
        type: "Sentence",
        raw: "",
        loc: {
            start: { column: NaN, line: NaN },
            end: { column: NaN, line: NaN }
        },
        range: [NaN, NaN],
        children: []
    };
}
exports.createEmptySentenceNode = createEmptySentenceNode;
function createNode(type, text, startPosition, endPosition) {
    return {
        type: type,
        raw: text,
        value: text,
        loc: {
            start: nowToLoc(startPosition),
            end: nowToLoc(endPosition)
        },
        range: [startPosition.offset, endPosition.offset]
    };
}
exports.createNode = createNode;
function nowToLoc(now) {
    return {
        line: now.line,
        column: now.column
    };
}
//# sourceMappingURL=sentence-splitter.js.map